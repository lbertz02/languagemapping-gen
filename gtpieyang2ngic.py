"""ngic style gtp ie output plugin

   Copyright 2017-2018 Lyle Bertz.
   Copyright 2017 Carl Moberg.

   Licensed under the Apache License, Version 2.0 (the :"License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

# pylint: disable=C0111

from __future__ import print_function

import optparse
import logging
import numbers

from pyang import plugin
from pyang import statements
from pyang import types
from pyang import error

logging.basicConfig(filename="test.log", level=logging.DEBUG)

#Used to capture refcounts for reporting
refcounts = {}
unknown_refs = []
# The number of values in an IE's ENUM that when exceeded will
# cause the generator to swith from #define to an enum type
ie_enum_define_limit = 3

def pyang_plugin_init():
    plugin.register_plugin(gtp2ngicPlugin())

class gtp2ngicPlugin(plugin.PyangPlugin):
    def add_output_format(self, fmts):
        fmts['ngic-ie'] = self

    def add_opts(self, optparser):
        optlist = [
            optparse.make_option('--ngic-ie-debug',
                                 dest='schema_debug',
                                 action="store_true",
                                 help='NGIC IE Generator debug'),
            optparse.make_option('--ngic-ie-path',
                                 dest='schema_path',
                                 help='NGIC IE Generator path'),
            optparse.make_option('--ngic-ie-title',
                                 dest='schema_title',
                                 help='NGIC IE Generator title')
            ]

        group = optparser.add_option_group("NGIC IE Generator specific options")
        group.add_options(optlist)

    def setup_ctx(self, ctx):
        ctx.opts.stmts = None

    def setup_fmt(self, ctx):
        ctx.implicit_errors = False

    def emit(self, ctx, modules, fd):
        root_stmt = modules[0]
        if ctx.opts.schema_debug:
            logging.basicConfig(level=logging.DEBUG)
            print("")
        if ctx.opts.schema_path is not None:
            logging.debug("schema_path: %s", ctx.opts.schema_path)
            path = ctx.opts.schema_path
            root_stmt = find_stmt_by_path(modules[0], path)
        else:
            path = None

        if ctx.opts.schema_title is not None:
            schema_title = ctx.opts.schema_title
        else:
            schema_title = root_stmt.arg

        description_str = "Generated by pyang from module %s" % modules[0].arg
        result = "/* Information Element type values according to 3GPP TS 29.274 Table 8.1-1 */\n"

        #Process IEs first
        # Produce Registry values
        ie_reg = {}
        counter = 1000
        if root_stmt.i_groupings is not None and len(root_stmt.i_groupings) > 0:
            ies = [x for x in root_stmt.i_groupings.values() if is_ie(x)]
            for stmt in ies:
                try:
                    w = int(get_substmt( (u'ts29274-ies-f40', u'ie-type'), stmt).arg)
                except ValueError:
                    w = counter
                    counter += 1
                ie_reg[w] = stmt.arg
            if len(ies) > 0:
                for key in sorted(ie_reg.iterkeys()):
                    result += "{:<65}".format("#define IE_" + ie_reg[key].upper()) + "(" + str(key) +")\n"
        
        #Produce enumerations
        if root_stmt.i_typedefs is not None and len(root_stmt.i_typedefs) > 0:
            for stmt in root_stmt.i_typedefs.values():
                type = get_substmt("type", stmt)
                if type is not None and type.arg == "enumeration":
                    enums = {}
                    e_count = 0
                    for enum in type.search("enum"):
                        val = get_substmt("value",enum)
                        if val is not None:
                            v = val.arg
                        else:
                            v = e_count
                            e_count += 1
                        enums[v] = enum.arg
                    if len(enums) > ie_enum_define_limit:
                        result += print_enum_struct(stmt.arg, enums)
                    else:
                        result += print_enum_defs(stmt.arg, enums)

        result += "#pragma pack(1)\n\n"

        #Produce non-IE Typedefs
        if root_stmt.i_groupings is not None and len(root_stmt.i_groupings) > 0:
            non_ies = [x for x in root_stmt.i_groupings.values() if not is_ie(x)]
            for stmt in non_ies:
                result += print_grouping(stmt) + "\n\n"

        #Produce IE Typedefs
        if root_stmt.i_groupings is not None and len(root_stmt.i_groupings) > 0:
            ies = [x for x in root_stmt.i_groupings.values() if is_ie(x)]
            for stmt in ies:
                result += print_grouping(stmt) + "\n\n"
        fd.write( result )

def get_substmts(name, stmt):
    if hasattr(stmt, 'substmts'):
        return [x for x in stmt.substmts if x.keyword == name]
    return []

def get_substmt(name, stmt):
    x = get_substmts(name, stmt)
    if len(x) > 0:
        return x[0]
    return None

def find_stmt_by_path(module, path):
    logging.debug("in find_stmt_by_path with: %s %s path: %s", module.keyword, module.arg, path)

    if path is not None:
        spath = path.split("/")
        if spath[0] == '':
            spath = spath[1:]

    children = [child for child in module.i_children
                if child.keyword in statements.data_definition_keywords]

    while spath is not None and len(spath) > 0:
        match = [child for child in children if child.arg == spath[0]
                 and child.keyword in statements.data_definition_keywords]
        if len(match) > 0:
            logging.debug("Match on: %s, path: %s", match[0].arg, spath)
            spath = spath[1:]
            children = match[0].i_children
            logging.debug("Path is now: %s", spath)
        else:
            logging.debug("Miss at %s, path: %s", children, spath)
            raise error.EmitError("Path '%s' does not exist in module" % path)

    logging.debug("Ended up with %s %s", match[0].keyword, match[0].arg)
    return match[0]

def is_ie(stmt):
    if hasattr(stmt, 'substmts'):
        y = [x for x in stmt.substmts if x.keyword == (u'ts29274-ies-f40', u'ie-type')]
        if len(y) > 0:
            return True
    return False

def print_grouping(stmt):
    children = {}
    if hasattr(stmt, 'substmts'):
        #Collect all container/leaf/leaf-list/list children
        result = ""
        for x in stmt.substmts:
            if x.keyword in [ 'leaf', 'container', 'leaf-list', 'list' ]:
                #result = str(x.keyword) + " with name = " + x.arg + "\n"
                #for zz in x.substmts:
                #    result += "item: " + str(zz.keyword) + "\n"
                z = [y for y in x.substmts if y.keyword == (u'ts29274-ies-f40', u'order')]
                #result += "length = " + str(len(z)) + "\n"
                if len(z) > 0:
                    aa = get_substmt('mandatory', x)
                    da_truth = True if (aa is not None and aa.arg == "true") else False
                    children[z[0]] = (x, da_truth)
                        
        #Determine if the mandatory header structure is in effect
        first_element_mandatory = None
        has_non_mandatory_member = False
        for key in sorted(children.iterkeys()):
            (child, mandatory) = children[key]
            if first_element_mandatory is None:
                logging.debug("First member %s is mandatory = %s", child.arg, mandatory)
                first_element_mandatory = mandatory
            if not mandatory:
                logging.debug("Non-mandatory member %s ", child.arg)
                has_non_mandatory_member = True

        subtype = "_ie" if is_ie(stmt) else ""
        result += "typedef struct " + stmt.arg.lower() + subtype + "_t {\n"

        if first_element_mandatory and has_non_mandatory_member:
            result += "\tstruct " + stmt.arg.lower() + subtype + "_hdr_t {\n"
            indent = "\t\t"
            close_header_struct = True
        else:
            indent = "\t"
            close_header_struct = False
        #result += str(children)

        for key in sorted(children.iterkeys()):
            (child, mandatory) = children[key]
            if (not mandatory) and close_header_struct:
                result += "\t} " + stmt.arg.lower() + subtype + "_hdr;\n"
                close_header_struct = False
                indent = "\t"
            last_child_mandatory = mandatory
            result += produce_ie_member(child, indent)
        return result + "} " + stmt.arg.lower() + subtype + ";\n"

def produce_ie_member(stmt, indent):
    type_stmt = get_substmt('type', stmt)
    type = stmt.arg
    
    result = ""
    if stmt.keyword == 'leaf':
        bitslength = get_substmt('length', type_stmt)
        if bitslength is not None:
            blengths = bitslength.arg.split("|")
            if blengths[0] == '':
                blengths = blengths[1:]
            if len(blengths) > 1:
                result += indent + "union type_union_u {\n"
                for bl in blengths:
                    blength = 0 if bl is None else int( bl )
                    (tp, endl) = get_member_info( type_stmt.arg, blength )
                    result += indent + "\t" + tp + " " + stmt.arg + endl
                result += indent + "} type_union;\n"
            else:
                blength = 0 if bitslength is None else int( blengths[0] )
                (tp, endl) = get_member_info( type_stmt.arg, blength )
                result += indent + tp + " " + stmt.arg + endl
        else:
            result = indent + "char* " + stmt.arg + ";\n"
    elif stmt.keyword == 'leaf-list':
        bitslength = get_substmt('length', type_stmt)
        mx = get_substmt('max-elements', type_stmt)
        mx_elms = 0 if mx is None else int( mx.arg )
        
        bl = 0 if bitslength is None else int( bitslength.arg )
        (tp, endl) = get_member_info( type_stmt.arg, bl )
        if (":" in endl) or ("[" in endl):
            result += indent + "struct {\n"
            result += indent + "\t" + tp + " " + stmt.arg + endl
            result += indent + "} "
            if mx_elms == 0:
                result += "*data"
            else:
                result += "data"
        else:
            result += indent + tp + " "
        if mx_elms > 0:
            result +=  stmt.arg + "[" + mx_elms + "]\n;"
        else:
            result +=  "*" + stmt.arg + ";\n"
    elif stmt.keyword == 'container':
        mandatory = get_substmt('mandatory', stmt)
        uses_stmt = get_substmt('uses', stmt)
        is_ptr = "" if mandatory is not None and mandatory.arg == 'true' else "*"
        result += indent + uses_stmt.arg + "_t " + is_ptr + stmt.arg + ";\n"
    else:
        result = "NOT SUPPORTED - TYPE = " + stmt.keyword + " for member = " + stmt.arg + "\n"
    return result

def get_member_info(type, bitlength):
    (rlength, modulus) = roundToMultipleOf8( bitlength )
    if modulus != 0:
        endl = " :"  + str(bitlength) + ";\n"
    else:
        endl = ";\n"
    if rlength == 16:
        tgt_type = "uint16_t"
    elif rlength == 32:
        tgt_type = "uint32_t"
    elif rlength == 8:
        tgt_type = "uint8_t"
    elif modulus == 0 and rlength > 8:
        tgt_type = "uint8_t"
        endl = "[" + str(rlength / 8) + "];\n"
    elif type == 'binary':
        tgt_type = "char* "
    else:
        tgt_type = "????"
        endl = " This was the disaster we were waiting for in the generator. Hand code it!\n";
    return (tgt_type, endl)


def roundToMultipleOf8(val):
    if val == 0:
        return (0, 0)
    m = val % 8
    if m == 0:
        return (val, 0)
    return ((val + 8 - m), m)

def print_enum_struct(nm, enums):
    res = "enum " + nm.lower() + " {\n"
    for key in sorted(enums.iterkeys()):
        res += "\t" + nm.upper() + "_" + enums[key].upper() + " = " + str(key) + ",\n"
    res += "};\n\n"
    return res

def print_enum_defs(nm, enums):
    res = ""
    for key in sorted(enums.iterkeys()):
        res += "{:<67}".format("#define " + nm.upper() + "_" + enums[key].upper()) + "(" + str(key) + ")\n"
    return res + "\n"
